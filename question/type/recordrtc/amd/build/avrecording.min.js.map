{"version":3,"file":"avrecording.min.js","sources":["../src/avrecording.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n//\n\n/**\n * JavaScript to the recording work.\n *\n * We would like to thank the creators of atto_recordrtc, whose\n * work originally inspired this.\n *\n * This script uses some third-party JavaScript and loading that within Moodle/ES6\n * requires some contortions. The main classes here are:\n *\n * * Recorder - represents one recording widget. This works in a way that is\n *   not particularly specific to this question type.\n * * RecordRtcQuestion - represents one question, which may contain several recorders.\n *   It deals with the interaction between the recorders and the question.\n *\n * @module    qtype_recordrtc/avrecording\n * @copyright 2019 The Open University\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Log from 'core/log';\nimport ModalFactory from 'core/modal_factory';\nimport Notification from 'core/notification';\n\n/**\n * Verify that the question type can work. If not, show a warning.\n *\n * @return {string} 'ok' if it looks OK, else 'nowebrtc' or 'nothttps' if there is a problem.\n */\nfunction checkCanWork() {\n    if (!(navigator.mediaDevices && window.MediaRecorder)) {\n        return 'nowebrtc';\n    }\n\n    if (!(location.protocol === 'https:' || location.host.indexOf('localhost') !== -1)) {\n        return 'nothttps';\n    }\n\n    return 'ok';\n}\n\nconst RecorderPromise = import(M.cfg.wwwroot + '/question/type/recordrtc/js/mp3-mediarecorder@4.0.5/worker.umd.js').then(() => {\n    return import(M.cfg.wwwroot + '/question/type/recordrtc/js/mp3-mediarecorder@4.0.5/index.umd.js');\n\n}).then(recorderModule => {\n    const Mp3MediaRecorder = recorderModule.Mp3MediaRecorder;\n\n    const workerURL = URL.createObjectURL(new Blob([\n        // Now load the script (UMD version) in the Workers context.\n        \"importScripts('\" + M.cfg.wwwroot + \"/question/type/recordrtc/js/mp3-mediarecorder@4.0.5/worker.umd.js');\",\n\n        // The above index.umd.js script exports all methods in a new mp3EncoderWorker object.\n        \"mp3EncoderWorker.initMp3MediaEncoder({vmsgWasmUrl: '\" +\n        M.cfg.wwwroot + \"/question/type/recordrtc/js/vmsg@0.4.0/vmsg.wasm'});\",\n    ], {type: 'application/javascript'}));\n\n    /**\n     * Object for actually doing the recording.\n     *\n     * The recorder can be in one of several states, which is stored in a data-state\n     * attribute on the outer span (widget). The states are:\n     *\n     *  - new:       there is no recording yet. Button shows 'Start recording' (audio) or 'Start camera' (video).\n     *  - starting:  (video only) camera has started, but we are not recording yet. Button show 'Start recording'.\n     *  - recording: Media is being recorded. Pause button visible if allowed. Main button shows 'Stop'. Countdown displayed.\n     *  - paused:    If pause was pressed. Media recording paused, but resumable. Pause button changed to say 'resume'.\n     *  - saving:    Media being uploaded. Progress indication shown. Pause button hidden if was visible.\n     *  - recorded:  Recording and upload complete. Buttons shows 'Record again'.\n     *\n     * @param {HTMLElement} widget the DOM node that is the top level of the whole recorder.\n     * @param {(AudioSettings|VideoSettings)} mediaSettings information about the media type.\n     * @param {Object} owner the object we are doing the recording for. Must provide three callback functions\n     *                       showAlert notifyRecordingComplete notifyButtonStatesChanged.\n     * @param {Object} uploadInfo object with fields uploadRepositoryId, draftItemId, contextId and maxUploadSize.\n     * @constructor\n     */\n    function Recorder(widget, mediaSettings, owner, uploadInfo) {\n        /**\n         * @type {Recorder} reference to this recorder, for use in event handlers.\n         */\n        const recorder = this;\n\n        /**\n         * @type {MediaStream} during recording, the stream of incoming media.\n         */\n        let mediaStream = null;\n\n        /**\n         * @type {MediaRecorder} the recorder that is capturing stream.\n         */\n        let mediaRecorder = null;\n\n        /**\n         * @type {Blob[]} the chunks of data that have been captured so far during the current recording.\n         */\n        let chunks = [];\n\n        /**\n         * @type {number} number of bytes recorded so far, so we can auto-stop\n         * before hitting Moodle's file-size limit.\n         */\n        let bytesRecordedSoFar = 0;\n\n        /**\n         * @type {number} when paused, the time left in milliseconds, so we can auto-stop at the time limit.\n         */\n        let timeRemaining = 0;\n\n        /**\n         * @type {number} while recording, the time we reach the time-limit, so we can auto-stop then.\n         * This is milliseconds since Unix epoch, so comparable with Date.now().\n         */\n        let stopTime = 0;\n\n        /**\n         * @type {number} intervalID returned by setInterval() while the timer is running.\n         */\n        let countdownTicker = 0;\n\n        const button = widget.querySelector('button.qtype_recordrtc-main-button');\n        const pauseButton = widget.querySelector('.qtype_recordrtc-pause-button button');\n        const controlRow = widget.querySelector('.qtype_recordrtc-control-row');\n        const mediaElement = widget.querySelector('.qtype_recordrtc-media-player ' + mediaSettings.name);\n        const noMediaPlaceholder = widget.querySelector('.qtype_recordrtc-no-recording-placeholder');\n        const timeDisplay = widget.querySelector('.qtype_recordrtc-time-left');\n\n        widget.addEventListener('click', handleButtonClick);\n        this.uploadMediaToServer = uploadMediaToServer; // Make this method available.\n\n        /**\n         * Handles clicks on the start/stop and pause buttons.\n         *\n         * @param {Event} e\n         */\n        function handleButtonClick(e) {\n            const clickedButton = e.target.closest('button');\n            if (!clickedButton) {\n                return; // Not actually a button click.\n            }\n            e.preventDefault();\n            switch (widget.dataset.state) {\n                case 'new':\n                case 'recorded':\n                    startRecording();\n                    break;\n                case 'starting':\n                    startSaving();\n                    break;\n                case 'recording':\n                    if (clickedButton === pauseButton) {\n                        pause();\n                    } else {\n                        stopRecording();\n                    }\n                    break;\n                case 'paused':\n                    if (clickedButton === pauseButton) {\n                        resume();\n                    } else {\n                        stopRecording();\n                    }\n                    break;\n            }\n        }\n\n        /**\n         * Start recording (because the button was clicked).\n         */\n        function startRecording() {\n\n            if (mediaSettings.name === 'audio') {\n                mediaElement.parentElement.classList.add('hide');\n                noMediaPlaceholder.classList.add('hide');\n                timeDisplay.classList.remove('hide');\n\n            } else {\n                mediaElement.parentElement.classList.remove('hide');\n                noMediaPlaceholder.classList.add('hide');\n            }\n            pauseButton?.parentElement.classList.remove('hide');\n\n            // Change look of recording button.\n            button.classList.remove('btn-outline-danger');\n            button.classList.add('btn-danger');\n\n            // Disable other question buttons when current widget stared recording.\n            disableAllButtons();\n\n            // Empty the array containing the previously recorded chunks.\n            chunks = [];\n            bytesRecordedSoFar = 0;\n            navigator.mediaDevices.getUserMedia(mediaSettings.mediaConstraints)\n                .then(handleCaptureStarting)\n                .catch(handleCaptureFailed);\n        }\n\n        /**\n         * Callback once getUserMedia has permission from the user to access the recording devices.\n         *\n         * @param {MediaStream} stream the stream to record.\n         */\n        function handleCaptureStarting(stream) {\n            mediaStream = stream;\n\n            // Setup the UI for during recording.\n            mediaElement.srcObject = stream;\n            mediaElement.muted = true;\n            if (mediaSettings.name === 'audio') {\n                startSaving();\n            } else {\n                mediaElement.play();\n                mediaElement.controls = false;\n\n                widget.dataset.state = 'starting';\n                setButtonLabel('startrecording');\n                widget.querySelector('.qtype_recordrtc-stop-button').disabled = false;\n            }\n\n            // Make button clickable again, to allow starting/stopping recording.\n            if (pauseButton) {\n                pauseButton.disabled = false;\n            }\n            button.disabled = false;\n            button.focus();\n        }\n\n        /**\n         * For recording types which show the media during recording,\n         * this starts the loop-back display, but does not start recording it yet.\n         */\n        function startSaving() {\n            // Initialize MediaRecorder events and start recording.\n            if (mediaSettings.name === 'audio') {\n                mediaRecorder = new Mp3MediaRecorder(mediaStream,\n                    {worker: new Worker(workerURL)});\n            } else {\n                mediaRecorder = new MediaRecorder(mediaStream,\n                    getRecordingOptions());\n            }\n\n            mediaRecorder.ondataavailable = handleDataAvailable;\n            mediaRecorder.onpause = handleDataAvailable;\n            mediaRecorder.onstop = handleRecordingHasStopped;\n            mediaRecorder.start(1000); // Capture in one-second chunks. Firefox requires that.\n\n            widget.dataset.state = 'recording';\n            setButtonLabel('stoprecording');\n            startCountdownTimer();\n            if (mediaSettings.name === 'video') {\n                button.parentElement.classList.add('hide');\n                controlRow.classList.remove('hide');\n                controlRow.classList.add('d-flex');\n            }\n        }\n\n        /**\n         * Callback that is called by the media system for each Chunk of data.\n         *\n         * @param {BlobEvent} event\n         */\n        function handleDataAvailable(event) {\n            if (!event.data) {\n                return; // It seems this can happen around pausing.\n            }\n\n            // Check there is space to store the next chunk, and if not stop.\n            bytesRecordedSoFar += event.data.size;\n            if (uploadInfo.maxUploadSize >= 0 && bytesRecordedSoFar >= uploadInfo.maxUploadSize) {\n\n                // Extra check to avoid alerting twice.\n                if (!localStorage.getItem('alerted')) {\n                    localStorage.setItem('alerted', 'true');\n                    stopRecording();\n                    owner.showAlert('nearingmaxsize');\n\n                } else {\n                    localStorage.removeItem('alerted');\n                }\n            }\n\n            // Store the next chunk of data.\n            chunks.push(event.data);\n\n            // Notify form-change-checker that there is now unsaved data.\n            // But, don't do this in question preview where it is just annoying.\n            if (typeof M.core_formchangechecker !== 'undefined' &&\n                !window.location.pathname.endsWith('/question/preview.php')) {\n                M.core_formchangechecker.set_form_changed();\n            }\n        }\n\n        /**\n         * Pause recording.\n         */\n        function pause() {\n            // Stop the count-down timer.\n            stopCountdownTimer();\n            setPauseButtonLabel('resume');\n            mediaRecorder.pause();\n            widget.dataset.state = 'paused';\n        }\n\n        /**\n         * Continue recording.\n         */\n        function resume() {\n            // Stop the count-down timer.\n            resumeCountdownTimer();\n            widget.dataset.state = 'recording';\n            setPauseButtonLabel('pause');\n            mediaRecorder.resume();\n        }\n\n        /**\n         * Start recording (because the button was clicked or because we have reached a limit).\n         */\n        function stopRecording() {\n            // Disable the button while things change.\n            button.disabled = true;\n\n            // Stop the count-down timer.\n            stopCountdownTimer();\n\n            // Update the button.\n            button.classList.remove('btn-danger');\n            button.classList.add('btn-outline-danger');\n            if (pauseButton) {\n                setPauseButtonLabel('pause');\n                pauseButton.parentElement.classList.add('hide');\n            }\n\n            // Ask the recording to stop.\n            mediaRecorder.stop();\n\n            // Also stop each individual MediaTrack.\n            const tracks = mediaStream.getTracks();\n            for (let i = 0; i < tracks.length; i++) {\n                tracks[i].stop();\n            }\n        }\n\n        /**\n         * Callback that is called by the media system once recording has finished.\n         */\n        function handleRecordingHasStopped() {\n            if (widget.dataset.state === 'new') {\n                // This can happens if an error occurs when recording is starting. Do nothing.\n                return;\n            }\n\n            // Set source of the media player.\n            const blob = new Blob(chunks, {type: mediaRecorder.mimeType});\n            mediaElement.srcObject = null;\n            mediaElement.src = URL.createObjectURL(blob);\n\n            // Show audio player with controls enabled, and unmute.\n            mediaElement.muted = false;\n            mediaElement.controls = true;\n            mediaElement.parentElement.classList.remove('hide');\n            noMediaPlaceholder.classList.add('hide');\n            mediaElement.focus();\n\n            if (mediaSettings.name === 'audio') {\n                timeDisplay.classList.add('hide');\n\n            } else {\n                button.parentElement.classList.remove('hide');\n                controlRow.classList.add('hide');\n                controlRow.classList.remove('d-flex');\n            }\n\n            // Ensure the button while things change.\n            button.disabled = true;\n            button.classList.remove('btn-danger');\n            button.classList.add('btn-outline-danger');\n            widget.dataset.state = 'recorded';\n\n            if (chunks.length > 0) {\n                owner.notifyRecordingComplete(recorder);\n            }\n        }\n\n        /**\n         * Function that handles errors from the recorder.\n         *\n         * @param {DOMException} error\n         */\n        function handleCaptureFailed(error) {\n            Log.debug('Audio/video question: error received');\n            Log.debug(error);\n\n            setPlaceholderMessage('recordingfailed');\n            setButtonLabel('recordagainx');\n            button.classList.remove('btn-danger');\n            button.classList.add('btn-outline-danger');\n            widget.dataset.state = 'new';\n\n            if (mediaRecorder) {\n                mediaRecorder.stop();\n            }\n\n            // Changes 'CertainError' -> 'gumcertain' to match language string names.\n            const stringName = 'gum' + error.name.replace('Error', '').toLowerCase();\n\n            owner.showAlert(stringName);\n            enableAllButtons();\n        }\n\n        /**\n         * Start the countdown timer.\n         */\n        function startCountdownTimer() {\n            timeRemaining = widget.dataset.maxRecordingDuration * 1000;\n            resumeCountdownTimer();\n            updateTimerDisplay();\n        }\n\n        /**\n         * Stop the countdown timer.\n         */\n        function stopCountdownTimer() {\n            timeRemaining = stopTime - Date.now();\n            if (countdownTicker !== 0) {\n                clearInterval(countdownTicker);\n                countdownTicker = 0;\n            }\n        }\n\n        /**\n         * Start or resume the countdown timer.\n         */\n        function resumeCountdownTimer() {\n            stopTime = Date.now() + timeRemaining;\n            if (countdownTicker === 0) {\n                countdownTicker = setInterval(updateTimerDisplay, 100);\n            }\n        }\n\n        /**\n         * Update the countdown timer, and stop recording if we have reached 0.\n         */\n        function updateTimerDisplay() {\n            const millisecondsRemaining = stopTime - Date.now();\n            const secondsRemaining = Math.round(millisecondsRemaining / 1000);\n            const secs = secondsRemaining % 60;\n            const mins = Math.round((secondsRemaining - secs) / 60);\n\n            timeDisplay.innerText = M.util.get_string('timedisplay', 'qtype_recordrtc',\n                    {mins: pad(mins), secs: pad(secs)});\n\n            if (millisecondsRemaining <= 0) {\n                stopRecording();\n            }\n        }\n\n        /**\n         * Zero-pad a string to be at least two characters long.\n         *\n         * @param {number} val e.g. 1 or 10\n         * @return {string} e.g. '01' or '10'.\n         */\n        function pad(val) {\n            const valString = val + '';\n\n            if (valString.length < 2) {\n                return '0' + valString;\n            } else {\n                return '' + valString;\n            }\n        }\n\n        /**\n         * Trigger the upload of the recorded media back to Moodle.\n         */\n        function uploadMediaToServer() {\n            setButtonLabel('uploadpreparing');\n\n            // First we need to get the media data from the media element.\n            const fetchRequest = new XMLHttpRequest();\n            fetchRequest.open('GET', mediaElement.src);\n            fetchRequest.responseType = 'blob';\n            fetchRequest.addEventListener('load', handleRecordingFetched);\n            fetchRequest.send();\n        }\n\n        /**\n         * Callback called once we have the data from the media element, ready to upload to Moodle.\n         *\n         * @param {ProgressEvent} e\n         */\n        function handleRecordingFetched(e) {\n            const fetchRequest = e.target;\n            if (fetchRequest.status !== 200) {\n                // No data.\n                return;\n            }\n\n            // Blob is now the media that the audio/video tag's src pointed to.\n            const blob = fetchRequest.response;\n\n            // Create FormData to send to PHP filepicker-upload script.\n            const formData = new FormData();\n            formData.append('repo_upload_file', blob, widget.dataset.recordingFilename);\n            formData.append('sesskey', M.cfg.sesskey);\n            formData.append('repo_id', uploadInfo.uploadRepositoryId);\n            formData.append('itemid', uploadInfo.draftItemId);\n            formData.append('savepath', '/');\n            formData.append('ctx_id', uploadInfo.contextId);\n            formData.append('overwrite', '1');\n\n            const uploadRequest = new XMLHttpRequest();\n            uploadRequest.addEventListener('readystatechange', handleUploadReadyStateChanged);\n            uploadRequest.upload.addEventListener('progress', handleUploadProgress);\n            uploadRequest.addEventListener('error', handleUploadError);\n            uploadRequest.addEventListener('abort', handleUploadAbort);\n            uploadRequest.open('POST', M.cfg.wwwroot + '/repository/repository_ajax.php?action=upload');\n            uploadRequest.send(formData);\n        }\n\n        /**\n         * Callback for when the upload completes.\n         * @param {ProgressEvent} e\n         */\n        function handleUploadReadyStateChanged(e) {\n            const uploadRequest = e.target;\n            if (uploadRequest.readyState !== 4) {\n                return; // Not finished yet. We will get more of these events when it is.\n            }\n\n            const response = JSON.parse(uploadRequest.responseText);\n            if (response.errorcode) {\n                handleUploadError(); // Moodle sends back errors with a 200 status code for some reason!\n            }\n\n            if (uploadRequest.status === 200) {\n                // When request finished and successful.\n                setButtonLabel('recordagainx');\n                enableAllButtons();\n            } else if (uploadRequest.status === 404) {\n                setPlaceholderMessage('uploadfailed404');\n                enableAllButtons();\n            }\n        }\n\n        /**\n         * Callback for updating the upload progress.\n         * @param {ProgressEvent} e\n         */\n        function handleUploadProgress(e) {\n            setButtonLabel('uploadprogress', Math.round(e.loaded / e.total * 100) + '%');\n        }\n\n        /**\n         * Callback for when the upload fails with an error.\n         */\n        function handleUploadError() {\n            setPlaceholderMessage('uploadfailed');\n            enableAllButtons();\n        }\n\n        /**\n         * Callback for when the upload fails with an error.\n         */\n        function handleUploadAbort() {\n            setPlaceholderMessage('uploadaborted');\n            enableAllButtons();\n        }\n\n        /**\n         * Display a progress message in the upload progress area.\n         *\n         * @param {string} langString\n         * @param {string|null} [a] optional variable to populate placeholder with\n         */\n        function setButtonLabel(langString, a) {\n            if (!a) {\n                // Seemingly unnecessary space inside the span is needed for screen-readers, and it must be a non-breaking space.\n                a = '<span class=\"sr-only\">&nbsp;' + widget.dataset.widgetName + '</span>';\n            }\n            button.innerHTML = M.util.get_string(langString, 'qtype_recordrtc', a);\n        }\n\n        /**\n         * Display a progress message in the upload progress area.\n         *\n         * @param {string} langString\n         */\n        function setPauseButtonLabel(langString) {\n            pauseButton.innerText = M.util.get_string(langString, 'qtype_recordrtc');\n        }\n\n        /**\n         * Display a message in the upload progress area.\n         *\n         * @param {string} langString\n         */\n        function setPlaceholderMessage(langString) {\n            noMediaPlaceholder.textContent = M.util.get_string(langString, 'qtype_recordrtc');\n            mediaElement.parentElement.classList.add('hide');\n            noMediaPlaceholder.classList.remove('hide');\n        }\n\n        /**\n         * Select best options for the recording codec.\n         *\n         * @returns {Object}\n         */\n        function getRecordingOptions() {\n            const options = {};\n\n            // Get the relevant bit rates from settings.\n            if (mediaSettings.name === 'audio') {\n                options.audioBitsPerSecond = mediaSettings.bitRate;\n            } else if (mediaSettings.name === 'video') {\n                options.videoBitsPerSecond = mediaSettings.bitRate;\n                options.videoWidth = mediaSettings.width;\n                options.videoHeight = mediaSettings.height;\n\n                // Go through our list of mimeTypes, and take the first one that will work.\n                for (let i = 0; i < mediaSettings.mimeTypes.length; i++) {\n                    if (MediaRecorder.isTypeSupported(mediaSettings.mimeTypes[i])) {\n                        options.mimeType = mediaSettings.mimeTypes[i];\n                        break;\n                    }\n                }\n            }\n\n            return options;\n        }\n\n        /**\n         * Enable all buttons in the question.\n         */\n        function enableAllButtons() {\n            disableOrEnableButtons(true);\n            owner.notifyButtonStatesChanged();\n        }\n\n        /**\n         * Disable all buttons in the question.\n         */\n        function disableAllButtons() {\n            disableOrEnableButtons(false);\n        }\n\n        /**\n         * Disables/enables other question buttons when current widget started recording/finished recording.\n         *\n         * @param {boolean} enabled true if the button should be enabled.\n         */\n        function disableOrEnableButtons(enabled = false) {\n            widget.closest('.que').querySelectorAll('button, input[type=submit], input[type=button]').forEach(\n                function(button) {\n                    button.disabled = !enabled;\n                }\n            );\n        }\n    }\n\n    return Recorder;\n});\n\n/**\n * Object that controls the settings for recording audio.\n *\n * @param {string} bitRate desired audio bitrate.\n * @constructor\n */\nfunction AudioSettings(bitRate) {\n    this.name = 'audio';\n    this.bitRate = parseInt(bitRate, 10);\n    this.mediaConstraints = {\n        audio: true\n    };\n    this.mimeTypes = [\n        'audio/mpeg',\n    ];\n}\n\n/**\n * Object that controls the settings for recording video.\n *\n * @param {string} bitRate desired video bitrate.\n * @param {string} width desired width.\n * @param {string} height desired height.\n * @constructor\n */\nfunction VideoSettings(bitRate, width, height) {\n    this.name = 'video';\n    this.bitRate = parseInt(bitRate, 10);\n    this.width = parseInt(width, 10);\n    this.height = parseInt(height, 10);\n    this.mediaConstraints = {\n        audio: true,\n        video: {\n            width: {ideal: this.width},\n            height: {ideal: this.height}\n        }\n    };\n    this.mimeTypes = [\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=h264,opus',\n        'video/webm;codecs=vp8,opus'\n    ];\n}\n\n/**\n * Represents one record audio or video question.\n *\n * @param {string} questionId id of the outer question div.\n * @param {Object} settings like audio bit rate.\n * @constructor\n */\nfunction RecordRtcQuestion(questionId, settings) {\n    const questionDiv = document.getElementById(questionId);\n\n    // Check if the RTC API can work here.\n    const result = checkCanWork();\n    if (result === 'nothttps') {\n        questionDiv.querySelector('.https-warning').classList.remove('hide');\n        return;\n    } else if (result === 'nowebrtc') {\n        questionDiv.querySelector('.no-webrtc-warning').classList.remove('hide');\n        return;\n    }\n\n    // Make the callback functions available.\n    this.showAlert = showAlert;\n    this.notifyRecordingComplete = notifyRecordingComplete;\n    this.notifyButtonStatesChanged = setSubmitButtonState;\n    const thisQuestion = this;\n\n    // We may have more than one widget in a question.\n    questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget').forEach(function(widget) {\n        // Get the appropriate options.\n        let typeInfo;\n        if (widget.dataset.mediaType === 'audio') {\n            typeInfo = new AudioSettings(settings.audioBitRate);\n        } else {\n            typeInfo = new VideoSettings(settings.videoBitRate, settings.videoWidth, settings.videoHeight);\n        }\n\n        // Create the recorder.\n        RecorderPromise.then(Recorder => {\n            new Recorder(widget, typeInfo, thisQuestion, settings);\n            return 'Not used';\n        }).catch(Notification.exception);\n    });\n    setSubmitButtonState();\n\n    /**\n     * Set the state of the question's submit button.\n     *\n     * If any recorder does not yet have a recording, then disable the button.\n     * Otherwise, enable it.\n     */\n    function setSubmitButtonState() {\n        let anyRecorded = false;\n        questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget').forEach(function(widget) {\n            if (widget.dataset.state === 'recorded') {\n                anyRecorded = true;\n            }\n        });\n        const submitButton = questionDiv.querySelector('input.submit[type=submit]');\n        if (submitButton) {\n            submitButton.disabled = !anyRecorded;\n        }\n    }\n\n    /**\n     * Show a modal alert.\n     *\n     * @param {string} subject Subject is the content of the alert (which error the alert is for).\n     * @return {Promise}\n     */\n    function showAlert(subject) {\n        return ModalFactory.create({\n            type: ModalFactory.types.ALERT,\n            title: M.util.get_string(subject + '_title', 'qtype_recordrtc'),\n            body: M.util.get_string(subject, 'qtype_recordrtc'),\n        }).then(function(modal) {\n            modal.show();\n            return modal;\n        });\n    }\n\n    /**\n     * Callback called when the recording is completed.\n     *\n     * @param {Recorder} recorder the recorder.\n     */\n    function notifyRecordingComplete(recorder) {\n        recorder.uploadMediaToServer();\n    }\n}\n\n/**\n * Initialise a record audio or video question.\n *\n * @param {string} questionId id of the outer question div.\n * @param {Object} settings like audio bit rate.\n */\nfunction init(questionId, settings) {\n    M.util.js_pending('init-' + questionId);\n    new RecordRtcQuestion(questionId, settings);\n    M.util.js_complete('init-' + questionId);\n}\n\nexport {\n    init\n};\n"],"names":["questionId","settings","M","util","js_pending","RecordRtcQuestion","js_complete","RecorderPromise","cfg","wwwroot","then","recorderModule","Mp3MediaRecorder","workerURL","URL","createObjectURL","Blob","type","widget","mediaSettings","owner","uploadInfo","recorder","this","mediaStream","mediaRecorder","chunks","bytesRecordedSoFar","timeRemaining","stopTime","countdownTicker","button","querySelector","pauseButton","controlRow","mediaElement","name","noMediaPlaceholder","timeDisplay","handleCaptureStarting","stream","srcObject","muted","startSaving","play","controls","dataset","state","setButtonLabel","disabled","focus","worker","Worker","MediaRecorder","options","audioBitsPerSecond","bitRate","videoBitsPerSecond","videoWidth","width","videoHeight","height","i","mimeTypes","length","isTypeSupported","mimeType","getRecordingOptions","ondataavailable","handleDataAvailable","onpause","onstop","handleRecordingHasStopped","start","maxRecordingDuration","resumeCountdownTimer","updateTimerDisplay","parentElement","classList","add","remove","event","data","size","maxUploadSize","localStorage","getItem","removeItem","setItem","stopRecording","showAlert","push","core_formchangechecker","window","location","pathname","endsWith","set_form_changed","stopCountdownTimer","setPauseButtonLabel","stop","tracks","getTracks","blob","src","notifyRecordingComplete","handleCaptureFailed","error","debug","setPlaceholderMessage","stringName","replace","toLowerCase","enableAllButtons","Date","now","clearInterval","setInterval","millisecondsRemaining","secondsRemaining","Math","round","secs","mins","innerText","get_string","pad","val","valString","handleRecordingFetched","e","fetchRequest","target","status","response","formData","FormData","append","recordingFilename","sesskey","uploadRepositoryId","draftItemId","contextId","uploadRequest","XMLHttpRequest","addEventListener","handleUploadReadyStateChanged","upload","handleUploadProgress","handleUploadError","handleUploadAbort","open","send","readyState","JSON","parse","responseText","errorcode","loaded","total","langString","a","widgetName","innerHTML","textContent","disableOrEnableButtons","notifyButtonStatesChanged","enabled","closest","querySelectorAll","forEach","clickedButton","preventDefault","navigator","mediaDevices","getUserMedia","mediaConstraints","catch","startRecording","pause","resume","uploadMediaToServer","responseType","AudioSettings","parseInt","audio","VideoSettings","video","ideal","questionDiv","document","getElementById","result","protocol","host","indexOf","subject","ModalFactory","create","types","ALERT","title","body","modal","show","setSubmitButtonState","thisQuestion","anyRecorded","submitButton","typeInfo","mediaType","audioBitRate","videoBitRate","Recorder","Notification","exception"],"mappings":"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"}