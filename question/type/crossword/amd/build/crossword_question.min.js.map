{"version":3,"file":"crossword_question.min.js","sources":["../src/crossword_question.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * CrosswordQuestion base class handle every common function.\n *\n * @module qtype_crossword/crossword_question\n * @copyright 2022 The Open University\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport class CrosswordQuestion {\n\n    // Arrow Left key.\n    ARROW_LEFT = 'ArrowLeft';\n\n    // Arrow Right key.\n    ARROW_RIGHT = 'ArrowRight';\n\n    // Arrow Up key.\n    ARROW_UP = 'ArrowUp';\n\n    // Arrow Down key.\n    ARROW_DOWN = 'ArrowDown';\n\n    // End key.\n    END = 'End';\n\n    // Home key.\n    HOME = 'Home';\n\n    // Delete key.\n    DELETE = 'Delete';\n\n    // Backspace key.\n    BACKSPACE = 'Backspace';\n\n    // Z key.\n    Z_KEY = 'z';\n\n    // A key.\n    A_KEY = 'a';\n\n    // Enter key.\n    ENTER = 'Enter';\n\n    // Maximum row of crossword.\n    MAX_ROW = 30;\n\n    /**\n     * Constructor for crossword question.\n     *\n     * @param {Object} options The input options for the crossword.\n     */\n    constructor(options) {\n        let defaultOption = {\n            colsNum: 10,\n            rowsNum: 10,\n            words: [],\n            target: '#crossword',\n            isPreview: false,\n            previewSetting: {backgroundColor: '#ffffff', borderColor: '#000000', textColor: '#ffffff', conflictColor: '#f4cece'},\n            cellWidth: 31,\n            cellHeight: 31,\n            wordNumber: -1,\n            coordinates: '',\n            maxSizeCell: 50,\n            minSizeCell: 30,\n            specialCharacters: {hyphen: '-', space: ' '},\n        };\n        // Merge options.\n        defaultOption = {...defaultOption, ...options};\n        // Set options.\n        this.options = defaultOption;\n        // Get target element.\n        const targetEls = document.querySelectorAll(defaultOption.target);\n        for (let i = 0; i < targetEls.length; i++) {\n            if (!targetEls[i].querySelector('svg')) {\n                this.crosswordEl = targetEls[i];\n                this.options.crosswordEl = targetEls[i];\n                if (!this.options.isPreview) {\n                    this.options.words = this.retrieveWordData();\n                }\n                break;\n            }\n        }\n    }\n\n    /**\n     * Get word data.\n     *\n     * @return {Array} Word data list.\n     */\n    retrieveWordData() {\n        const clueEls = this.options.crosswordEl\n            .closest('.qtype_crossword-grid-wrapper')\n            .querySelectorAll('.contain-clue .wrap-clue');\n        if (clueEls.length === 0) {\n            return [];\n        }\n        return [...clueEls].map(el => {\n            const number = parseInt(el.dataset.questionid);\n            const startRow = parseInt(el.dataset.startrow);\n            const startColumn = parseInt(el.dataset.startcolumn);\n            const length = parseInt(el.dataset.length);\n            const orientation = parseInt(el.dataset.orientation);\n            const clue = el.dataset.clue;\n            return {number, startRow, startColumn, length, orientation, clue};\n        }).sort((clueA, clueB) => clueA.number - clueB.number);\n    }\n\n    /**\n     * Get alphabet character from the index.\n     *\n     * @param {Number} index The character index number start from 0.\n     *\n     * @return {String} Alphabet character, In case index number higher than 25,\n     *  we will add one letter before the current one like Excel: AA, AB, AC, AD, AE etc.\n     */\n    getColumnLabel(index) {\n        let text = '';\n\n        // Get the integer of division and subtraction by 1,\n        // The firstLetterIndex will start from -1\n        // and increments every index adding more 26.\n        const firstLetterIndex = Math.trunc(index / 26) - 1;\n\n        // Get remainder from division result.\n        // The lastLetterIndex value is the index of the second letter.\n        let lastLetterIndex = index % 26;\n\n        // In case firstLetterIndex < -1 we will not show the first letter.\n        if (firstLetterIndex > -1) {\n            text = this.retrieveCharacterByIndex(firstLetterIndex);\n        }\n        // Adding the last letter.\n        text += this.retrieveCharacterByIndex(lastLetterIndex);\n\n        return text;\n    }\n\n    /**\n     * Get alphabet character by index.\n     *\n     * @param {Number} index Position character number.\n     * @return {String} Alphabet character.\n     */\n    retrieveCharacterByIndex(index) {\n        return String.fromCharCode(\"A\".charCodeAt(0) + index);\n    }\n\n    /**\n     * Check the content of the answer for the existence of special characters.\n     *\n     * @param {String} answer The answer string need to be check.\n     * @return {Boolean} True if the answer is invalid.\n     */\n    isContainSpecialCharacters(answer) {\n        return /([^\\p{L}\\p{N}\\-\\s]+)/ugi.test(answer);\n    }\n\n    /**\n     * Generate underscore letter by length.\n     *\n     * @param {Number} length Expected length.\n     *\n     * @return {String} Underscore string.\n     */\n    makeUnderscore(length) {\n        const arr = Array.from({length}, () => '_');\n        return arr.join('');\n    }\n\n    /**\n     * Update the letter index of the word based on the word selected.\n     *\n     * @param {Object} word The word object.\n     */\n    updateLetterIndexForCells(word) {\n        const {wordNumber} = this.options;\n        const letterList = this.options.crosswordEl.querySelectorAll(`g[data-word*='(${wordNumber})']`);\n        const ignoreList = this.getIgnoreIndexByAnswerNumber(word.number);\n        // Convert letterList to array to use sort function.\n        const letterListArray = Array.prototype.slice.call(letterList, 0);\n        let letterIndex = 0;\n        // Rearrange the letters in the correct order.\n        letterListArray.sort((a, b) => {\n            let aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'x'));\n            let bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'x'));\n            if (word.orientation) {\n                aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'y'));\n                bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'y'));\n            }\n            return aValue - bValue;\n        }).forEach(el => {\n            // Incase the letter index in ignore list we must skip it.\n            if (ignoreList.includes(letterIndex)) {\n                letterIndex = this.generateLetterIndex(letterIndex, ignoreList, word.length);\n            }\n            // Update letter index.\n            el.dataset.letterindex = letterIndex;\n            letterIndex++;\n        });\n    }\n\n    /**\n     * Calculate and retreive the letter index.\n     *\n     * @param {Number} letterIndex The current letter index.\n     * @param {Array} ignoreList The ignore list; If the letter contains space or hyphen\n     * @param {Number} wordLength The word length.\n     * characters. We have to ignore it.\n     * @return {Number} The new letter index.\n     */\n    generateLetterIndex(letterIndex, ignoreList, wordLength) {\n        letterIndex++;\n        // If the new letter index still in ignore list;\n        // We need to increase it again.\n        if (ignoreList.includes(letterIndex) || letterIndex > wordLength - 1) {\n            return this.generateLetterIndex(letterIndex, ignoreList, wordLength);\n        }\n        return letterIndex;\n    }\n\n    /**\n     * Toggle focus the clue.\n     */\n    focusClue() {\n        const {wordNumber} = this.options;\n        const containCrosswordEl = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper');\n        const clueEl = containCrosswordEl.querySelector(`.wrap-clue[data-questionid='${wordNumber}']`);\n        const clueFocusEl = containCrosswordEl.querySelector(`.wrap-clue.focus`);\n        // Remove the current focus cell.\n        if (clueFocusEl) {\n            clueFocusEl.classList.remove('focus');\n        }\n        // Add focus cell.\n        if (clueEl) {\n            clueEl.classList.add('focus');\n        }\n    }\n\n    /**\n     * Set sticky clue for the mobile version.\n     */\n    setStickyClue() {\n        const stickyClue = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelector('.sticky-clue');\n        const {wordNumber, words} = this.options;\n        const word = words.find(o => o.number === parseInt(wordNumber));\n        const clueWrapperSelector = `.contain-clue .wrap-clue[data-questionid=\"${wordNumber}\"]`;\n        const clueContent = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper')\n            .querySelector(clueWrapperSelector + ' .clue-content').innerHTML;\n        const clueCount = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper')\n            .querySelector(clueWrapperSelector + ' .clue-count').innerText;\n        if (!stickyClue && word) {\n            return;\n        }\n        let strongEl = stickyClue.querySelector('strong');\n        let clueEl = stickyClue.querySelector('span.clue');\n        let countEl = stickyClue.querySelector('span.count');\n        if (!strongEl) {\n            strongEl = document.createElement('strong');\n            strongEl.classList.add('mr-1', 'text-nowrap');\n            stickyClue.append(strongEl);\n        }\n        if (!clueEl) {\n            clueEl = document.createElement('span');\n            clueEl.classList.add('clue', 'clearfix');\n            stickyClue.append(clueEl);\n        }\n        if (!countEl) {\n            countEl = document.createElement('span');\n            countEl.classList.add('count', 'text-nowrap', 'ml-1');\n            stickyClue.append(countEl);\n        }\n        strongEl.innerText = `${word.number} ${this.options.orientation[word.orientation]}`;\n        clueEl.innerHTML = clueContent;\n        countEl.innerText = clueCount;\n    }\n\n    /**\n     * Focus crossword cell from the start index.\n     *\n     * @param {String} value The value string need to be replaced.\n     * @return {String} The value data.\n     */\n    replaceText(value) {\n        return value.replace(/([^\\p{L}\\p{N}\\s]+)/ugi, '');\n    }\n\n    /**\n     * Bind data to the clue.\n     *\n     * @param {Element} gEl The word letter.\n     * @param {String} key The letter data.\n     */\n    bindDataToClueInput(gEl, key) {\n        const {words} = this.options;\n        const rectEl = gEl.querySelector('rect');\n        const conflictPointX = rectEl.getAttributeNS(null, 'x');\n        const conflictPointY = rectEl.getAttributeNS(null, 'y');\n        let letterIndex, value;\n        if (gEl) {\n            let wordIds = gEl.dataset.word.match(/\\d+/g);\n            wordIds.forEach(wordId => {\n                const word = words.find(o => o.number === parseInt(wordId));\n                if (word) {\n                    letterIndex = this.findCellOrder(word, conflictPointX, conflictPointY);\n                    const clueInputEl = this.options.crosswordEl\n                        .closest('.qtype_crossword-grid-wrapper')\n                        .querySelector(`.wrap-clue[data-questionid='${wordId}'] input`);\n                    // Replace spaces with an underscore character before binding to the answer input.\n                    if (key === ' ') {\n                        key = '_';\n                    }\n                    letterIndex = this.findTheValidLetterIndex(letterIndex, word);\n                    value = this.replaceAt(clueInputEl.value, letterIndex, key);\n                    let answerString = value.toUpperCase() + this.makeUnderscore(word.length - value.length);\n                    const ignoreList = this.getIgnoreIndexByAnswerNumber(word.number, false);\n                    answerString = this.mapAnswerAndSpecialLetter(answerString, ignoreList[0]);\n                    clueInputEl.value = answerString;\n                }\n            });\n        }\n    }\n\n    /**\n     * Calculate the position of each letter of the word.\n     *\n     * @param {Object} word The current word object.\n     * @param {Number} key The letter index of word.\n     *\n     * @return {Object} The coordinates of letter.\n     */\n    calculatePosition(word, key) {\n        const {cellWidth, cellHeight} = this.options;\n        let x = cellWidth * word.startColumn;\n        let y = cellHeight * word.startRow;\n        if (word.orientation) {\n            y += (key * cellHeight);\n        } else {\n            x += (key * cellWidth);\n        }\n        return {x, y};\n    }\n\n    /**\n     * Replace letter at index.\n     *\n     * @param {String} text Text need to be replaced.\n     * @param {Number} index Letter index.\n     * @param {String} char The replace letter.\n     *\n     * @return {String} Underscore string.\n     */\n    replaceAt(text, index, char) {\n        let a = text.split('');\n        if (a[index] !== undefined) {\n            a[index] = char;\n        }\n        return a.join('');\n    }\n\n    /**\n     * Sync data to crossword cell from text.\n     *\n     * @param {String} text The text data.\n     * @param {Boolean} skipEmptyData Allow skip rendering blank answers,\n     *      if false, we will update the crossword grid even if the answer input is blank.\n     * @return {Boolean} Is valid text string.\n     */\n    syncLettersByText(text, skipEmptyData = true) {\n        const {wordNumber} = this.options;\n        // Skip empty string.\n        if (text.replace(/_/g, '').length === 0 && skipEmptyData) {\n            return false;\n        }\n        for (let i in text) {\n            const gEl = this.options.crosswordEl.querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${i}']`);\n            if (gEl) {\n                const letter = text[i].toUpperCase();\n                const textEl = gEl.querySelector('text.crossword-cell-text');\n                if (text[i] !== '_') {\n                    textEl.innerHTML = letter;\n                } else {\n                    textEl.innerHTML = '';\n                }\n                this.bindDataToClueInput(gEl, letter);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Toggle the highlight cells.\n     *\n     * @param {Object} word The word object.\n     * @param {Element} gEl The g element.\n     */\n    toggleHighlight(word, gEl) {\n        const {wordNumber, orientation, title} = this.options;\n        const focus = wordNumber;\n        const focusedEl = this.options.crosswordEl.querySelector('.crossword-cell-focussed');\n        if (focusedEl) {\n            focusedEl.classList.remove('crossword-cell-focussed');\n        }\n        // Remove current highlight cells.\n        this.options.crosswordEl.querySelectorAll('.crossword-cell-highlighted')\n            .forEach(el => el.classList.remove('crossword-cell-highlighted'));\n        // Set highlight cells.\n        this.options.crosswordEl.querySelectorAll(`g[data-word*='(${focus})'] rect`)\n            .forEach(el => {\n                    let titleData = '';\n                    if (el.closest('g').dataset.code === gEl.dataset.code) {\n                        el.classList.add('crossword-cell-focussed');\n                        const conflictPointX = gEl.querySelector('rect').getAttributeNS(null, 'x');\n                        const conflictPointY = gEl.querySelector('rect').getAttributeNS(null, 'y');\n                        // Update aria label.\n                        let letterIndex = this.findCellOrder(word, conflictPointX, conflictPointY);\n                        const data = {\n                            row: word.startRow + 1,\n                            column: word.startColumn + letterIndex + 1,\n                            number: word.number,\n                            orientation: orientation[word.orientation],\n                            clue: word.clue,\n                            letter: letterIndex + 1,\n                            count: word.length - this.getIgnoreIndexByAnswerNumber(wordNumber).length,\n                        };\n                        if (word.orientation) {\n                            data.row = word.startRow + letterIndex + 1;\n                            data.column = word.startColumn + 1;\n                        }\n                        titleData = this.replaceStringData(title, data);\n                        this.options.crosswordEl.querySelector('input.crossword-hidden-input')\n                            .setAttributeNS(null, 'aria-label', titleData);\n\n                    } else {\n                        el.classList.add('crossword-cell-highlighted');\n                    }\n                }\n            );\n    }\n\n    /**\n     * Replace string data.\n     *\n     * @param {String} str The string need to be replaced.\n     * @param {Object} data The data.\n     *\n     * @return {String} The replaced string.\n     */\n    replaceStringData(str, data) {\n        for (let key in data) {\n            str = str.replace(`{${key}}`, data[key]);\n        }\n        return str;\n    }\n\n    /**\n     * Sync data between clue section and crossword.\n     */\n    syncDataForInit() {\n        const {words} = this.options;\n        // Loop every input into clue section.\n        this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelectorAll('.wrap-clue input')\n            .forEach(element => {\n                // Tricky, update word number.\n                this.options.wordNumber = parseInt(element.closest('.wrap-clue').dataset.questionid);\n                const word = words.find(o => o.number === this.options.wordNumber);\n                if (!word) {\n                    return;\n                }\n                // Sorting and Updating letter index.\n                this.updateLetterIndexForCells(word);\n                // The value will be filled into the valid cell.\n                this.syncLettersByText(element.value);\n            });\n        // Set wordNumber by default value.\n        this.options.wordNumber = -1;\n    }\n\n    /**\n     * Set size for crossword.\n     *\n     * @param {Element} svg The svg element.\n     * @return {Element} The svg element after set size.\n     */\n    setSizeForCrossword(svg) {\n        const {colsNum, maxSizeCell, minSizeCell} = this.options;\n        // Get max width and min width for crossword with current max cell size and min cell size.\n        const maxWidth = colsNum * maxSizeCell;\n        const minWidth = colsNum * minSizeCell;\n        // To avoid the case that the crossword has too high a height when we have many rows (eg 30) and too few columns (eg 3).\n        // We will limit the maximum height of the crossword.\n        // This reduces the size of the crossword but still ensures that the size of each cell keep in the range min and max sizes.\n        const maxHeight = this.MAX_ROW * minSizeCell;\n        svg.style.cssText = `max-width: ${maxWidth}px; min-width: ${minWidth}px;\n            max-height: ${maxHeight}px;`;\n        return svg;\n    }\n\n    /**\n     * Get ignore letter index by answer number.\n     *\n     * @param {Number} answerNumber The answer number.\n     * @param {Boolean} forceFlatObject Convert ignore index object to array and flat it; By default is true;\n     * @return {Array} List ignore letter index.\n     */\n    getIgnoreIndexByAnswerNumber(answerNumber, forceFlatObject = true) {\n        const {crosswordEl} = this.options;\n        // Get ignore indexes list from element. It should look like {\"space\":[3, 5],\"hyphen\":[11]};\n        // It contains special characters that exist in that answer with their index.\n        // With the example data above, we can see that in this answer there are two spaces and one hyphen;\n        // The indexes of the space are 3, 5 and with the hyphen are 11.\n        let ignoreIndexes = crosswordEl.closest('.qtype_crossword-grid-wrapper')?.querySelector(\n            `.contain-clue .wrap-clue[data-questionid='${answerNumber}']`)?.dataset?.ignoreindexes ?? '[]';\n        ignoreIndexes = JSON.parse(ignoreIndexes);\n        if (Array.isArray(ignoreIndexes) && ignoreIndexes.length === 0) {\n            ignoreIndexes = {};\n        }\n        // In the case, we just want to get the index of the special characters existing in this answer.\n        // E.g: [3, 5, 11].\n        if (forceFlatObject) {\n            return Object.values(ignoreIndexes).flat().sort((a, b) => {\n                return a - b;\n            });\n        }\n        // Return full ignoreIndexes.\n        // E.g: [{space:[3, 5], hyphen:[11]}].\n        return [ignoreIndexes];\n    }\n\n    /**\n     * Based on the answer string and special list, we will mix them together;\n     * e.g: the answer has 4 letters and the special list is {hyphen: [2]},\n     * the result will be: _ _ - _. We will replace the 2nd letter with the hyphen character (based on replaceLetter option).\n     *\n     * @param {String} answer The answer string which will be handled.\n     * @param {Object} specialList The special object contains a list of special characters and their indexes.\n     * E.g: {hyphen: [1, 2]}.\n     * @return {String} The mixed answer.\n     */\n    mapAnswerAndSpecialLetter(answer, specialList) {\n        const specials = this.options.specialCharacters;\n        if (Object.keys(specialList).length === 0 && specialList.constructor === Object) {\n            return answer;\n        }\n        for (let character in specialList) {\n            if (specials[character] !== undefined) {\n                for (let index of specialList[character]) {\n                    // Replace character.\n                    answer = this.replaceAt(answer, index, specials[character]);\n                }\n            }\n        }\n        return answer;\n    }\n\n    /**\n     * Find the next or previous valid cell in the grid crossword based on index.\n     * E.g: Answer ALL-IN contains 6 letters, but in the crossword grid only 5 cells are displayed (no hyphen).\n     * And the letterindex property of each cell will be 0, 1, 2, 4, 5 (ignoring the hyphen index). So\n     * the next cell of the letter L (index 2) will be I (index 4).\n     *\n     * @param {Number} wordNumber The word selected number.\n     * @param {Object} word The word selected object.\n     * @param {Number} selectionIndex The selection index.\n     * @param {Boolean} isAscending If True find the next cell else find the previous cell.\n     * @return {Array} List contains the next/previous selection index and the next/previous g element.\n     */\n    findTheClosestCell(wordNumber, word, selectionIndex, isAscending = true) {\n        let count = selectionIndex;\n        let number = -1;\n        let notFound = true;\n        let closestCell = [];\n\n        // Find the next cell.\n        if (isAscending) {\n            number = Math.abs(number);\n        }\n\n        // We have to iterate through the crossword cell of a specific answer to find the closest valid one.\n        while (notFound) {\n            // The special characters will not be shown in a grid,\n            // So we have to find another cell by increasing/decreasing the selection Index.\n            const gelEl = this.options.crosswordEl\n            .querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${count}']`);\n            if (gelEl || count > word.length || count <= 0) {\n                notFound = false;\n                closestCell = [count, gelEl];\n            }\n            count += number;\n        }\n        return closestCell;\n    }\n\n    /**\n     * Find the valid letter index of answer input.\n     * E.g: The answer contains a hyphen: ALL-IN and the answer input will be displayed\n     * _ _ _ - _ _. With a hyphen (index 4), the user cannot interact.\n     * So the next valid letter index right after the letter index 2 (Letter L) is 4 (not 3).\n     *\n     * @param {Number} selectedIndex The selected index.\n     * @param {Object} word The word selected object.\n     * @param {Boolean} isAscending Find index in ascending or descending order, default true.\n     * @return {Number} Return new valid letter index.\n     */\n    findTheValidLetterIndex(selectedIndex, word, isAscending = true) {\n        // Retrieve invalid index and sort it in ascending order.\n        const ignoreIndexes = this.getIgnoreIndexByAnswerNumber(word.number);\n        let number = -1;\n        // Find the next letter index.\n        if (isAscending) {\n            number = Math.abs(number);\n        }\n        // Since there's an index difference between the cell grid and the answer input\n        // (the grid cells won't display special characters) we'll add/minus the difference.\n        for (let invalidIndex of ignoreIndexes) {\n            if (selectedIndex >= invalidIndex) {\n                if (!isAscending && selectedIndex === invalidIndex) {\n                    continue;\n                }\n                selectedIndex += number;\n            }\n        }\n        return selectedIndex;\n    }\n\n    /**\n     * Find the valid cell index from answer index.\n     *\n     * @param {Object} word The word selected object.\n     * @param {Number} answerIndex The selected letter index.\n     * @param {Boolean} skipIgnoreIndex If true, we will not count invalid index; Default true.\n     * @return {Number} Return new valid cell index.\n     */\n    findCellIndexFromAnswerIndex(word, answerIndex, skipIgnoreIndex = true) {\n        // Get special index list.\n        let ignoreIndexes = this.getIgnoreIndexByAnswerNumber(word.number);\n        let cellIndex = answerIndex;\n        // Loop to find valid index.\n        for (let index = cellIndex; index < word.length; index++) {\n            if (ignoreIndexes.includes(index)) {\n                cellIndex++;\n            } else {\n                break;\n            }\n        }\n        // Return valid index excluding special index.\n        // E.g: With the answer: TIM BERNERS-LEE  the next letter after letter B (index 4) is E (index 5);\n        // If skipIgnoreIndex is true, we will not count letter space (index 3).\n        // So the new letter index will be 4.\n        if (skipIgnoreIndex) {\n            return cellIndex - ignoreIndexes.filter(index => index <= cellIndex).length;\n        }\n        return cellIndex;\n    }\n\n    /**\n     * Find the order of the cell (starting at 0) based on coordinate of that cell.\n     *\n     * @param {Object} word The word selected object.\n     * @param {String} xCoordinate The x coordinate of cell.\n     * @param {String} yCoordinate The y coordinate of cell.\n     * @return {Number} The cell order.\n     */\n    findCellOrder(word, xCoordinate, yCoordinate) {\n        const {cellWidth, cellHeight} = this.options;\n        const startPoint = this.calculatePosition(word, 0);\n        if (word.orientation) {\n            return (parseInt(yCoordinate) - startPoint.y) / (cellHeight);\n        }\n        return (parseInt(xCoordinate) - startPoint.x) / (cellWidth);\n    }\n}\n"],"names":["constructor","options","defaultOption","colsNum","rowsNum","words","target","isPreview","previewSetting","backgroundColor","borderColor","textColor","conflictColor","cellWidth","cellHeight","wordNumber","coordinates","maxSizeCell","minSizeCell","specialCharacters","hyphen","space","targetEls","document","querySelectorAll","i","length","querySelector","crosswordEl","this","retrieveWordData","clueEls","closest","map","el","number","parseInt","dataset","questionid","startRow","startrow","startColumn","startcolumn","orientation","clue","sort","clueA","clueB","getColumnLabel","index","text","firstLetterIndex","Math","trunc","lastLetterIndex","retrieveCharacterByIndex","String","fromCharCode","charCodeAt","isContainSpecialCharacters","answer","test","makeUnderscore","Array","from","join","updateLetterIndexForCells","word","letterList","ignoreList","getIgnoreIndexByAnswerNumber","letterListArray","prototype","slice","call","letterIndex","a","b","aValue","getAttributeNS","bValue","forEach","includes","generateLetterIndex","letterindex","wordLength","focusClue","containCrosswordEl","clueEl","clueFocusEl","classList","remove","add","setStickyClue","stickyClue","find","o","clueWrapperSelector","clueContent","innerHTML","clueCount","innerText","strongEl","countEl","createElement","append","replaceText","value","replace","bindDataToClueInput","gEl","key","rectEl","conflictPointX","conflictPointY","match","wordId","findCellOrder","clueInputEl","findTheValidLetterIndex","replaceAt","answerString","toUpperCase","mapAnswerAndSpecialLetter","calculatePosition","x","y","char","split","undefined","syncLettersByText","skipEmptyData","letter","textEl","toggleHighlight","title","focus","focusedEl","titleData","code","data","row","column","count","replaceStringData","setAttributeNS","str","syncDataForInit","element","setSizeForCrossword","svg","maxWidth","minWidth","maxHeight","MAX_ROW","style","cssText","answerNumber","forceFlatObject","ignoreIndexes","_crosswordEl$closest","_crosswordEl$closest$2","_crosswordEl$closest$3","ignoreindexes","JSON","parse","isArray","Object","values","flat","specialList","specials","keys","character","findTheClosestCell","selectionIndex","notFound","closestCell","abs","gelEl","selectedIndex","isAscending","invalidIndex","findCellIndexFromAnswerIndex","answerIndex","skipIgnoreIndex","cellIndex","filter","xCoordinate","yCoordinate","startPoint"],"mappings":"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"}